#!/bin/python3
import argparse
from configparser import ConfigParser
from datetime import datetime
from jinja2 import Template
import guestfs
import logging
import requests
import subprocess
import sys
import tempfile
import time
import os

_log = None


class ComposeFailure(Exception):
    pass


def run_command(cmd, stdin=None, **kwargs):
    _log.debug('Running command: %s', cmd)
    _log.debug('Stdin: %s', stdin)
    p = subprocess.Popen(cmd,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE,
                         **kwargs)
    stdout, stderr = p.communicate(stdin)
    rc = p.wait()

    _log.debug('Return code: %s', rc)
    _log.debug('Stdout: %s', stdout)
    _log.debug('Stderr: %s', stderr)

    if rc != 0:
        raise ComposeFailure('Command failed, status: %s, out: %s, err: %s'
                             % (rc, stdout, stderr))

    return stdout.decode('utf-8'), stderr.decode('utf-8')


def parse_args():
    parser = argparse.ArgumentParser(description='Hatlocker Compose script')
    parser.add_argument('--quiet', '-q', default=False, action='store_true')
    parser.add_argument('--verbose', '-v', default=0, action='count')
    parser.add_argument('--configuration', '-c', default='compose.cfg',
                        help='Compose config file')
    parser.add_argument('--workdir',
                        help='Working directory (temp if not specified)')
    # Arguments below this are for skipping compose steps for debugging
    parser.add_argument('--imageid',
                        help='Define an image ID if you want to continue')
    parser.add_argument('--skip-extraction', action='store_true',
                        help='Specify that guestfs extraction is done')
    parser.add_argument('--verity-uuid', help='Verity UUID')
    parser.add_argument('--verity-roothash', help='Verity root hash')
    parser.add_argument('--skip-efi-generation', action='store_true',
                        help='Skip EFI generation')
    return parser.parse_args()


def create_verity_table(workdir):
    _log.info('Creating verity table')
    stdout, stderr = run_command(['veritysetup', 'format', '--hash=sha256',
                                  '--data-block-size=512',
                                  os.path.join(workdir, 'rootvol'),
                                  os.path.join(workdir, 'hashvol')])
    _log.info('Verity table created, parsing')

    uuid = None
    roothash = None
    for line in stdout.split('\n'):
        line = line.strip()
        if line.startswith('UUID:'):
            _log.debug('UUID line found: %s', line)
            if uuid is not None:
                raise ComposeFailure('Second UUID line found')
            uuid = line.split()[-1]
            if len(uuid) != 36:
                raise ComposeFailure('UUID length not expected')
        elif line.startswith('Root hash:'):
            _log.debug('Roothash line found: %s' % line)
            if roothash is not None:
                raise ComposeFailure('Second root hash line found')
            roothash = line.split()[-1]
            if len(roothash) != 64:
                raise ComposeFailure('Roothash length not expected')
    if uuid is None:
        raise ComposeFailure('No UUID found')
    if roothash is None:
        raise ComposeFailure('No root hash found')
    _log.info('UUID: %s', uuid)
    _log.info('Root hash: %s', roothash)

    return uuid, roothash


def setup_logging(verbosity):
    global _log

    level = None
    if verbosity == -1:
        level = logging.CRITICAL
    elif verbosity == 0:
        level = logging.ERROR
    elif verbosity == 1:
        level = logging.WARNING
    elif verbosity == 2:
        level = logging.INFO
    elif verbosity >= 3:
        level = logging.DEBUG

    logging.basicConfig(level=level)
    _log = logging.getLogger(__name__)


def get_definitions(workdir, config):
    run_command(['git', 'clone', config['definitions']['git_url'],
                 os.path.join(workdir, 'definitions')])
    stdout, stderr = run_command(['git', 'rev-parse', 'HEAD'],
                                 cwd=os.path.join(workdir, 'definitions'))
    _log.info('Definitions hash: %s', stdout.strip())


def build_base_image(tdl, kscts, **kwargs):
    params = {}
    params['offline_icicle'] = '1'
    params['install_script'] = kscts
    with open(tdl) as f:
        params['template'] = f.read()
    params.update(kwargs)

    _log.info('Base image arguments: %s', params)

    res = requests.post('http://localhost:8080/imagefactory/base_images',
                        data=params)
    _log.info('Response code: %s', res.status_code)
    _log.debug('Response: %s', res.text)

    res.raise_for_status()
    res = res.json()
    return res['base_image']['id']


def wait_for_image(imageid):
    res = requests.get('http://localhost:8080/imagefactory/base_images/%s'
                       % imageid).json()
    status = res['base_image']['status']

    _log.info('Waiting for build to finish...')

    while status in ['NEW', 'PENDING', 'BUILDING']:
        _log.debug('Status: %s, percentage: %s',
                   status, res['base_image']['percent_complete'])
        time.sleep(10)
        res = requests.get('http://localhost:8080/imagefactory/base_images/%s'
                           % imageid).json()
        status = res['base_image']['status']

    status = res['base_image']['status']
    _log.info('Final status: %s', status)

    if status != 'COMPLETE':
        raise ComposeFailure('Base image build failed with status %s' % status)

    return imageid


def get_kickstart(workdir, config):
    tmpl = None
    with open(os.path.join(workdir, config['definitions']['kickstart'])) as f:
        tmpl = Template(f.read())
    env = {}
    env['now'] = datetime.utcnow().isoformat(timespec='minutes') + 'Z'
    return template.render(**env)


def create_cmdline(workdir, config, blkuuid, hashvol, roothash):
    cmds = ['root=/dev/mapper/rootfs',
            'console=tty0',
            'console=ttyS0,115200',
            'rhgb',
            'quiet',
            'LANG=en_US.UTF-8',
            'verity=blkuuid=%s,hashvol=%s,roothash=%s' %
            (blkuuid, hashvol, roothash)]
    cmdline = ' '.join(cmds)
    _log.info('Command line: %s', cmdline)
    with open(os.path.join(workdir, 'cmdline'), 'w') as f:
        f.write(cmdline)


def create_efi_binary(workdir, config):
    run_command(
        ['objcopy',
         '--add-section', '.osrel=%s' % os.path.join(workdir,
                                                     'definitions',
                                                     'osrelease'),
         '--add-section', '.cmdline=%s' % os.path.join(workdir, 'cmdline'),
         '--add-section', '.linux=%s' % os.path.join(workdir, 'vmlinuz'),
         '--add-section', '.initrd=%s' % os.path.join(workdir, 'initramfs'),
         config['efi']['stub_path'], os.path.join(workdir, 'efiapp')])


def extract_image(workdir, bodyfile):
    os.environ['LIBGUESTFS_BACKEND'] = 'direct'
    g = guestfs.GuestFS(python_return_dict=True)
    g.add_drive_opts(bodyfile, readonly=1)

    _log.info('Launching GuestFS')
    g.launch()
    _log.info('GuestFS ready')
    oss = g.inspect_os()
    _log.debug('OSs: %s', oss)
    if len(oss) != 1:
        raise ComposeFailure('Not exactly one OS found')
    osroot = oss[0]

    _log.info('Mounting filesystem')
    mps = g.inspect_get_mountpoints(osroot)
    _log.debug('Mountpoints: %s', mps)
    if not '/' in mps:
        raise ComposeFailure('No / found')
    if not '/boot' in mps:
        raise ComposeFailure('No /boot found')
    if len(mps) != 2:
        raise ComposeFailure('Extra partitions found')
    g.mount_ro(mps['/'], '/')
    g.mount_ro(mps['/boot'], '/boot')
    rootvol = mps['/']
    _log.info('Filesystems mounted')

    _log.info('Downloading kernel data')
    vmlinuz = None
    initramfs = None
    for fname in g.ls('/boot'):
        if fname.startswith('vmlinuz-') and not 'rescue' in fname:
            _log.debug('Vmlinuz found: %s', fname)
            if vmlinuz is not None:
                raise ComposeFailure('More than one vmlinuz found')
            vmlinuz = fname
        elif fname.startswith('initramfs-') and not 'rescue' in fname:
            _log.debug('Initramfs found: %s', fname)
            if initramfs is not None:
                raise ComposeFailure('More than one initramfs found')
            initramfs = fname
    if not vmlinuz:
        raise ComposeFailure('No vmlinuz found')
    if not initramfs:
        raise ComposeFailure('No initramfs found')
    _log.debug('Downloading vmlinuz: %s, initramfs: %s', vmlinuz, initramfs)
    g.download('/boot/%s' % vmlinuz, os.path.join(workdir, 'vmlinuz'))
    g.download('/boot/%s' % initramfs, os.path.join(workdir, 'initramfs'))
    _log.info('Kernel data downloaded')

    _log.info('Downloading root volume')
    g.download(rootvol, os.path.join(workdir, 'rootvol'))
    _log.info('Root volume downloaded')

    _log.info('Clearing up GuestFS')
    g.umount_all()
    _log.info('GuestFS cleared')


def get_rootvol_uuid(workdir):
    stdout, stderr = run_command(['blkid',
                                  os.path.join(workdir, 'rootvol')])
    stdout = stdout.strip().split()
    blkuuid = None
    for part in stdout:
        if part.startswith('UUID="'):
            _log.debug('UUID part found: %s', part)
            if blkuuid is not None:
                raise ComposeFailure('Multiple UUID parts found')
            # String example: UUID="44772f90-22e2-424a-ae5e-3e2064ace80d"
            blkuuid = part[6:-1]
            if len(blkuuid) != 36:
                raise ComposeFailure('UUID length unexpected')
    _log.info('Rootvol blkuuid: %s', blkuuid)
    return blkuuid


curphase = None
def phase_msg(phase=None):
    global curphase
    if phase:
        curphase = phase
        _log.info('START: %s', phase)
    else:
        _log.info('DONE: %s', curphase)


def compose(workdir, config, args):
    _log.info('Initializing compose')

    if args.imageid is not None:
        if not os.path.isdir(os.path.join(workdir, 'definitions')):
            raise ComposeFailure('Incorrect workdir specified')
        imgid = args.imageid
        _log.info('Continuing with provided image ID and definitions')
    else:
        # Getting definitions
        phase_msg('Get definitions')
        get_definitions(workdir, config)
        phase_msg()

        phase_msg('Generate kickstart')
        kscts = get_kickstart(workdir, config)
        _log.info('Kickstart: %s', kscts)
        phase_msg()

        # Build base image
        phase_msg('Building base image')
        imgid = build_base_image(
            os.path.join(workdir, 'definitions', config['definitions']['tdl']),
            kscts)
        _log.info('Image ID: %s', imgid)
        phase_msg()

    phase_msg('Waiting for base image to finish')
    wait_for_image(imgid)
    phase_msg()
    _log.info('Image ID: %s', imgid)

    bodyfile = config['imagefactory'].get('storage_body_path_template',
                                          vars={'imgid': imgid})
    if not os.path.isfile(bodyfile):
        raise ComposeFailure('Unable to find image body at %s' % bodyfile)
    _log.debug('Image body at: %s', bodyfile)

    if not args.skip_extraction:
        phase_msg('Extracting image contents')
        extract_image(workdir, bodyfile)
        phase_msg()

    if not args.verity_uuid:
        phase_msg('Creating verity hash volume')
        uuid, roothash = create_verity_table(workdir)
        phase_msg()
    else:
        uuid = args.verity_uuid
        roothash = args.verity_roothash

    # TODO: Determine hashvol name
    hashvol = 'hashvol'

    phase_msg('Determining rootvol uuid')
    blkuuid = get_rootvol_uuid(workdir)
    phase_msg()

    if not args.skip_efi_generation:
        phase_msg('Generating kernel command line')
        create_cmdline(workdir, config, blkuuid, hashvol, roothash)
        phase_msg()

        phase_msg('Generating EFI binary')
        create_efi_binary(workdir, config)
        phase_msg()


def main():
    args = parse_args()
    config = ConfigParser()
    if len(config.read(args.configuration)) != 1:
        print('Invalid configuration file specified')
        sys.exit(1)
    if args.quiet:
        args.verbose = -1
    setup_logging(args.verbose)

    _log.debug('Arguments: %s', args)

    if args.workdir is None:
        args.workdir = tempfile.mkdtemp(prefix='hatlocker-composer-workdir-')

    _log.debug('Workdir: %s', args.workdir)

    compose(args.workdir, config, args)


if __name__ == '__main__':
    main()
